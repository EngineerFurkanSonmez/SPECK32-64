# SPECK32-64 C Implementation

This repository contains a C implementation of the Speck 32/64 block cipher. Speck is a family of lightweight block ciphers designed by the National Security Agency (NSA). This specific version, Speck 32/64, operates on 32-bit blocks and uses a 64-bit key.

The implementation has been modularized into header (`speck.h`) and source (`speck.c`) files for the core cipher logic, and `main.c` provides an example usage.

## Core Files

*   **`speck.h`**: Header file containing the declarations for Speck32/64 functions and macros.
    *   Includes rotation macros `ROR` and `ROL`.
    *   Declares `speck32_key_schedule`, `speck32_encrypt`, and `speck32_decrypt`.
*   **`speck.c`**: Source file containing the implementations of the Speck32/64 functions.
*   **`main.c`**: Contains an example `main()` function demonstrating the usage of the cipher functions. This includes encrypting a sample plaintext and attempting to decrypt the ciphertext.
*   **`Makefile`**: For easy compilation of the project.

## API Documentation (from `speck.h`)

### `void speck32_key_schedule(const uint16_t K[4], uint16_t round_keys[22])`

*   **Description:** Generates the 22 round keys required for Speck32/64 encryption and decryption from a 64-bit master key.
*   **Parameters:**
    *   `K`: A 4-element array of `uint16_t` representing the 64-bit master key. The key is expected such that `K[0]` is the least significant word (`k_0`) and `K[3]` is the most significant word (`k_3`) according to the Speck paper's notation for key scheduling.
    *   `round_keys`: A 22-element array of `uint16_t` where the generated round keys will be stored.

### `void speck32_encrypt(uint16_t block[2], const uint16_t round_keys[22])`

*   **Description:** Encrypts a 32-bit data block using the generated round keys.
*   **Parameters:**
    *   `block`: A 2-element array of `uint16_t` representing the 32-bit data block to be encrypted (e.g., `block[0]` is x, `block[1]` is y). The encrypted data will be stored back in this array.
    *   `round_keys`: The array of round keys generated by `speck32_key_schedule`.

### `void speck32_decrypt(uint16_t block[2], const uint16_t round_keys[22])`

*   **Description:** Decrypts a 32-bit data block using the generated round keys.
*   **Parameters:**
    *   `block`: A 2-element array of `uint16_t` representing the 32-bit data block to be decrypted. The decrypted data will be stored back in this array.
    *   `round_keys`: The array of round keys generated by `speck32_key_schedule`.

## Usage

### Compilation

To compile the code, use the provided `Makefile`:

```bash
make
```

This will generate an executable named `speck_cipher`.

To clean compiled files:
```bash
make clean
```

### Running the Example

The `main.c` file includes a `main` function that demonstrates the usage of the cipher. After compiling, run the executable:

```bash
./speck_cipher
```

This will encrypt and then attempt to decrypt a sample data block, printing the original, encrypted, and decrypted values to the console.

**Note on Correctness:** The key schedule logic in `speck.c` has been updated to align with the official Speck paper. However, there appears to be a persistent issue in the decryption logic (present in the original code as well) that results in incorrect plaintext recovery. While the encryption and key schedule now follow the standard, the decryption does not successfully reverse the encryption for the provided example or standard test vectors.

## License

This project is licensed under the terms of the LICENSE file. (Assuming a standard license file like MIT, Apache 2.0, etc. is present. If not, consider adding one.)

## Contributing

Contributions are welcome! If you'd like to contribute, please follow these steps:

1.  Fork the repository.
2.  Create a new branch for your feature or bug fix.
3.  Make your changes.
4.  Ensure your code compiles and runs correctly (or note any known issues).
5.  Submit a pull request with a clear description of your changes.

---
*This README was updated to reflect modularization and current code status.*
